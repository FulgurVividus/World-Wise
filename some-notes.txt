#1. To configure ESLint in React application:
npm install eslint vite-plugin-eslint eslint-config-react-app --save-dev

Then config the project to integrate with these packages:
create a file .eslintrc.json

In the .eslintrc.json file, we can configure the behavior of ESLint:
{
  "extends": "react-app"
}

After that, we also gotta our vite project with this ESLint, add these to vite.config.js:
import eslint from "vite-plugin-eslint";
export default defineConfig({
  plugins: [react(), eslint()],
});

#2. 'Pages' folder is for structural components

#3. React Router:
In this project: npm i react-router-dom@6
Actual: npm i react-router

#4. In <Route path="*" element={...} /> (in App.jsx):
'*' - this will catch all the routes that were not matched to other routes.

#5. In <Route path="/" element={...} /> (in App.jsx):
'*' - root path (homepage)

#6. <Link to="/">...</Link> instead of <a>...</a>:
In order not to reload the whole page but instead just update the DOM, you must use 
<Link to="/endpoint">...</ Link>

#7. <NavLink to=''>...</NavLink> (example - in PageNav.jsx):
Currently visiting link gets 'active' class and additionally does the same as Link.

#8. CSS Modules:
It comes out of Vite and npx, so nothing needed to install 
Create one external CSS file per component
Example: PageNav.jsx => PageNav.module.css
Note: don't use element selectors

#9. To make a class from componentName.module.css global:
In this module.css files itself do this syntax
:global(.class) {
  some styles...
}

#10. CSS Modules class names:
Define their names in camel case

#11. Nested Routing:
<Route path="app" element={...}>
  <Route index element={...} />
  <Route path="cities" element={...} />
  <Route path="countries" element={...} />
  <Route path="form" element={...} />
</Route>

here the 'app' is the parent route and others are child routes.

index - it's a default route, if none of the routes match, it'll go to the default one.

<Outlet /> - similar to {children} whenever we pass some element inside another element in JSX
But here instead of elements, we pass Route.

#12. Fake API:
npm i json-server
Then add this to 'scripts': "server": "json-server --watch folder_where_data/file_name.json --port 9000"
Then write command - npm run server

#13. Dynamic routes with URL parameters:
We do it in 3 steps 
-> 1. we create a new route
-> 2. we link to that route
-> 3. in that route, we read the state from the URL

Example: 
this path is linked to this component
<Route path="cities/:whatever_name_we_give_to_parameter" element={<Component />} />

useParams() - to get the data from the URL, use this hook. It returns object, so store it in a variable and destructure it. Example: City.jsx file. 

#14. Reading and Setting a Query String:
useSearchParams - to read data from 'query string' of the URL. It's similar to useState, returns the array [current_state, updater_function] => [searchParams, setSearchParams].
Example of how to use is in Map.jsx file.

#15. Programmatic Navigation with useNavigate (imperative way):
Programmatic Navigation - means to move to a new URL without the user having to click on any link.
The most use case is after submitting a form.

useNavigate() - this custom hook returns a function 'navigate'.
Example in Map.jsx file.
Example in BackButton.jsx, -1 means go back to one step in browser history 

#16. Programmatic navigation with <Navigate replace to="..." /> (declarative way):
Not used so much.
The most use case is inside of nested routes

<Navigate replace to="..." /> - is like redirect according to="..."
replace - makes able to go back

Example in App.jsx

#17. Creating Cities Context:
Example: contexts folder -> CitiesContext.jsx

#18. Consuming the CitiesContext implementation is in CountryList.jsx and CityList.jsx files.

#19. Example of multiple classes of CSS Modules in the className is in CityItem.jsx file.

#20. Installed -> npm i react-leaflet leaflet 
NOTE: don't forget to import '@import' css according to documentation. Look in the index.css file

#21. useMap (provided by leaflet library):
Hook - to get current instance of the map that is currently being displayed 
Example: Map.jsx file

#22. useMapEvents():
Yet another custom hook from leaflet library

#23. hooks folder:
Custom hook should not necessarily be with .jsx extension if it doesn't have JSX in it.

#24. npm i react-datepicker:
Example: in Form.jsx file the <DatePicker /> component.

#25. newCity variable in Form.jsx file:
No need to include id in the new object as json server of fake API will automatically do it itself.

#26. POST request to fake API:
Example: createCity() function in CitiesContext.jsx.

#27. Advanced State Management:
Context + useReducer -> CitiesContext.jsx file in contexts folder.

#28. Fake User:
In FakeAuthContext.jsx, never have 'fake user' in real-world and personal applications.